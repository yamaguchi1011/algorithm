# # 整数の配列nums（長さn）と整数kが与えられます。

# 長さがkである連続した部分配列を見つけて、その平均値が最大となる部分配列の値を返します。計算誤差が10^-5以下の答えも受け入れられます。

# つまりスライディングウィンドウ
class Solution:
    def findMaxAverage(self, nums: list[int], k:int) -> float:
        # 平均値の最大値を保持する変数。numsの要素は負数もあるので負の無限大で初期化。つまり、計算結果が（今回だとk個の平均）がマイナス（０よりも小さくなる）になる可能性があるので、最も小さい値を初期値としておく。
        max_avg = float("-inf")
        # ウィンドウの合計値を保持する変数
        current_sum = 0
        # ウインドウの左側のインデックス
        left = 0
        # numsを一巡して走査。ループ変数rightはウインドウの右側のインデックス
        for right in range(len(nums)):
            # ウインドウの合計値にright番目の要素を追加
            current_sum += nums[right]
            # ウインドウ内の要素数がk個になった場合
            if (right-left) == k-1:
                # max_avgを更新 max関数でmax_avgとcurrent_sumのどっちが大きいかを比べている。大きい方でmax_avgを更新する
                max_avg = max(max_avg,current_sum/k)
                # ウインドウの左端の要素の値を合計値から引く
                current_sum -= nums[left]
                left += 1
        # 戻り値を返す
        return max_avg

solution_instance = Solution()

# result = solution_instance.findMaxAverage(nums = [1,12,-5,-6,50,3], k = 4)
result = solution_instance.findMaxAverage(nums = [5], k = 1)
print(result)  

# スライディングウィンドウ
# スライディングウィンドウ（Sliding Window）は、配列やリストなどのデータ構造内の特定の範囲を移動させながら処理するアルゴリズムの手法です。主に部分配列や部分文字列に対して、連続する区間を操作する際に利用されます。この手法は、特に連続した要素に関する問題に適しており、効率的な解法を提供することがあります。

# スライディングウィンドウの基本的なアイディアは次の通りです：

# ウィンドウを定義します。ウィンドウは、配列やリストの一部であり、通常は固定サイズを持ちます。

# ウィンドウの初期位置を設定します。

# ウィンドウを右方向にスライドさせながら、問題に適した処理を行います。

# ウィンドウが移動することで、新しい要素がウィンドウ内に加わり、古い要素がウィンドウから排除されます。

# 必要に応じて、ウィンドウ内の要素を操作し、条件を満たすか結果を得ます。

# 典型的なスライディングウィンドウの用途は、部分配列内の合計値、平均値、最大/最小値の計算や、特定の条件を満たす連続する要素の探索などです。この手法を用いることで、要素の再計算を効率的に行いながら、問題を解決することができます。

# スライディングウィンドウは、特に連続する区間を対象とする問題において、効率的でスマートなアプローチを提供することが多いため、アルゴリズム問題の解法として広く用いられています。例えば、連続する部分配列の最大和や、特定の条件を満たす最短部分文字列を求める問題などでよく利用されます。